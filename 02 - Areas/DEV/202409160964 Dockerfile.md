---
date:
  - 16/09/2024 09:54
tags: 
cssclasses:
  - image-borders
  - neutral-pen-black
---
# Основные заметки
- Является файлом-инструкцией для создания образа
- Слои создают следующие инструкции:
	- FROM
	- RUN
	- COPY
	- ADD
- Остальные лишь видоизменяют, описывают метаданные и сообщают Docker, что нужно сделать. 
- **Директивы парсера**: особый вид комментариев, влияющий на способ обработки следующих строк Dockerfile.
	- Пример ``# escape=` (backtick)`` — устнавливает новый символ для экранирования
- Переменные окружения поддерживаются в следующих инструкциях:
	- **ADD**
	- **COPY**
	- **ENV**
	- **EXPOSE**
	- **LABEL**
	- **USER**
	- **WORKDIR**
	- **VOLUME**
	- **STOPSIGNAL**
	- **ONBUILD (from v1.4)**
- Для исключения из слоев Dockerfile используется `.dockerignore` (в нем также все правила считываются по порядку)
	- `*/temp*` Исключаются файлы и каталоги имена которых начинаются с `temp` в любой поддиректории корня. К примеру, данный файл `/somedir/temporary.txt` будет исключен, как и этот каталог `/somedir/temp`
	- `*/*/temp*` Исключает файлы и каталоги чье название начинается с `temp` во всех каталогах второго уровня. К примеру, `/somedir/subdir/temporary.txt`
	- `temp?` Исключает файлы и папки в корневой директории чьи имена отличаются на один символ от `temp`. К примеру, `/tempa` и `/tempb` будут исключены
	- `*.md` 
	  `!README.md` используется для создания исключений.
	- Сравнение производится с помощью **Go filepath.Match** правил. Перед обработкой удаляются лишние пробелы и элементы **., ..** с помощью **Go filepath.Clean**. Строки оставшиеся пустыми после предобработки игнорируются.
- **FROM**
	- Задает базовый образ для предстоящих инструкций
	- Должнен быть первой командой (не считая комментариев и директив)
```Dockerfile
FROM <image>
# или
FROM <image>:<tag>
# или
FROM <image>@<digest>
```
- **FROM AS**
	- Используется для многоэтапной сборки
	```Dockerfile
	FROM golang:latest as build
	COPY . .
	RUN go build ./src/main.go
	
	FROM alpine:latest as production
	COPY --from=build /go/main .
	CMD ["./main"]
	```
	- Использование предыдущего образа возможно как через алиас, так и через по индексу
	```Dockerfile
	COPY --from=build /go/main
	COPY --from=0 /go/main
	```
- **MAINTAINER** `Alegory Farmor <google@gmail.com>`
	- Указывается автора образа
- **RUN**
	- Две формы записи
		- `shell`. `RUN <command>`
		- `exec`. `RUN ["executable", "param 1", "param 2"]`
		> **Примечание:** Для использование другой оболочки отличной от /bin/sh, используйте exec форму выполнения команды RUN ["/bin/bash", "-c", "echo hello"]
	   > 
	   > **Примечание:** Exec форма обрабатывается как JSON массив, это означает что вы должны разделять слова используя двойные кавычки (“) и ни в коем случае одинарные (‘).
	   > 
	   > **Примечание:** В отличие от shell формы, exec форма не вызывает командную оболочку. Это означает что обработки в нормальной оболочке не происходит. К примеру, RUN [ "echo", "$HOME" ] не будет осуществлять подстановку переменной $HOME. Если вам нужна обработка в оболочке, используйте shell форму или запускайте оболочку напрямую, к примеру: RUN [ "sh", "-c", "echo $HOME" ]. При использовании exec формы и запуска оболочки напрямую, как в случае с shell формой, подстановка переменных осуществляется оболочкой а не docker.
	   > 
	   > **Примечание:** При формате команды в виде JSON, необходимо экранировать обратные слеши. Это особенно актуально в Windows, где обратный слеш является разделителем пути. Следующая строка будет рассматриваться как shell форма а не JSON как это могло бы ожидаться: RUN ["c:\windows\system32\tasklist.exe"] Правильным синтаксисом в данном случае будет: RUN ["c:\\windows\\system32\\tasklist.exe"]

- **LABEL** `<key>=<value>`
	- Добавляет метаданные для образа
- **CMD**
	- Имеет 3 формы
		- `CMD [“exec”, ”param 1”, “param 2“]` <!-- exec форма, более предпочтительна -->
		- `CMD ["param 1", "param 2"]` <!-- в качестве параметров по умолчанию для ENTRYPOINT -->
		- `CMD command param1 param2` <!-- shell форма -->
	- Может использоваться только один раз в Dockerfile. При использовании несокльких, то выполнится самая последняя
	- **Основное предназначение**: передача параметров по умолчанию для запуска контейнера
***Главное отличие RUN и CMD: первый выполняет команду и коммитит изменения. Второй ничего не выполняет, лишь задает команду, которая выполнится при запуске контейнера.***
- **EXPOSE** `port [<port...]`
	- Определяет, какие порты будет слушать контейнер после запуска.
	- **Не откраывает порты контейнера для хоста**. Для этого потребуется в docker-compose или в команде определить, какие порты будут открыты.
- **ENV**
	- Задает переменные окружения, доступные всем последующим командам
	- Два варианта записи
		- `ENV key value` <!-- при единичном значении -->
		- `ENV key=value ...` <!-- при множественных значениях -->
- **ADD**
	- Два варианта
		- `ADD src... dest`
		- `ADD ["src",...,"dest"]` <!-- обязательно для путей с пробелами -->
	- Копирует файлы, папки и ресурсы из URL
	- Пути ко всем src должны быть относительно папки с Dockerfile
	- В качестве src может содержать названия файлов с wildcards
	- Все создаваемые файлы и папки принимают UID и GID равный 0
		- Однако src из URL на копируемый файл принимает права 600.
	- Первое вхождение и дальнейшее изменение src в ADD аннулирует кэш последующих инструкций в Dockerfile
- **COPY**
	- Две формы
		- `COPY src... dest`
		- `COPY ["src",...,"dest"]` <!-- используется для путей с пробелами -->
	- Копирует файлы и каталоги
- **ENTRYPOINT**
	- Две формы
		- `ENTRYPOINT ["executable", "param1", "param2"]` <!-- exec форма, предпочтительна -->
		- `ENTRYPOINT command param1 param2` <!-- shell форма -->
	- Задает исполняемый файл по умолчанию
	- Хорошо работает вместе с CMD, который может предоставлять аргументы для исполняемого файла.
		- Другие пользователи в свою очередь смогут переопределить аргументы для запуска файла по умолчанию
- **VOLUME**
	- Задает точку монтирования
	```Dockerfile
	FROM ubuntu
	RUN mkdir /myvol
	RUN echo "hello world" > /myvol/greeting
	VOLUME /myvol
	```
- **USER**
	- Устанавливает пользователя UID, от имени которого будет запущен образ
- **WORKDIR**
	- Устанавливает рабочий каталог, относительно которого будут выполняться RUN, CMD, ENTRYPOINT, COPY, ADD.
	- Инструкция может быть выполнена несколько раз
	```Dockerfile
	WORKDIR /a
	WORKDIR b
	WORKDIR c
	RUN pwd
	```
	- **В результате команда pwd из Dockerfile вернет значение /a/b/c.**
	- Таким же образом могут использоваться переменные окружения
- **ARG**
	- Используется для передачи аргументов, которые могут быть использованы, как обычные переменные
	- Имеет набор предустановленных переменных
		- HTTP_PROXY
		- http_proxy
		- HTTPS_PROXY
		- https_proxy
		- FTP_PROXY
		- ftp_proxy
		- NO_PROXY
		- no_proxy
	- Не сохраняются в собранном образе, в отличие от ENV, однако также влияют на контекст сборки.
- **ONBUILD**
	- Задает триггерные команды для образа1, который может быть использован в качестве FROM образа в дочернем образе2.
- **STOPSIGNAL**
	- Устанавливает сигнал системного вызова, который будет отправлен для завершения контейнера
- **HEALTHCHECK**
	- Имеет 2 формы
		- `HEALTHCHECK [OPTIONS] CMD command` <!-- проверяет состояние контейнера, выполняя внутри него команду -->
		- `HEALTHCHECK NONE` <!-- отключает любые проверки состояния из базового образа -->
	- Указывает Docker проверить, работает ли контейнер
	- Имеется 3 параметра
		- --interval=DURATION (по умолчанию: 30s)
		- --timeout=DURATION (по умолчанию: 30s)
		- --retries=N (по умолчанию: 3)
	- Статус завершения команды указывает на состояние контейнера. Возможные значения:
		- 0: success - контейнер исправен и готов к использованию
		- 1: unhealthy - контейнер работает неправильно
		- 2: reserved - не используйте данный код выхода
- **SHELL**
	- Позволяет изменить стандартную оболочку на пользовательскую
	- По умолчанию sh
	- Может использоваться несколько раз. Каждая следующая заменяет предыдущую и влияет на последующие команды
	```Dockerfile
	FROM windowsservercore
	
	# Executed as cmd /S /C echo default
	RUN echo default
	
	# Executed as cmd /S /C powershell -command Write-Host default
	RUN powershell -command Write-Host default
	
	# Executed as powershell -command Write-Host Hello
	SHELL ["powershell", "-command"]
	RUN Write-Host hello
	
	# Executed as cmd /S /C echo hello
	SHELL ["cmd", "/S"", "/C"]
	RUN echo hello
	```